
Как в pytest оптимально организовать ресурс, который:

* создаётся долго (например, VM),
* ограничен по количеству,
* и желательно использовать его и как объект тестирования, и как подготовку (фикстуру) для следующих тестов.

---

## Проблема

* Если оформить "получение VM" как **тест**, pytest не сможет передать результат в другие тесты.
* Если оформить "получение VM" как **фикстуру**, она не будет отчётливо протестирована сама по себе (нет отдельного теста, который проверяет сам процесс получения).
* Повторять получение VM для каждого теста — долго и дорого.

---

## Решение — раздельные обязанности + share через фикстуру с `scope`

### 1. Вынеси **логику получения VM** в отдельную функцию (чистую бизнес-логику):

```python
def create_vm():
    # длительный процесс создания VM
    # raise исключения, если что-то не так
    return vm_instance
```

### 2. Напиши отдельный **тест**, который проверяет корректность `create_vm`:

```python
def test_create_vm():
    vm = create_vm()
    assert vm.is_ready()
```

### 3. Сделай фикстуру с подходящим `scope` (например, `"session"` или `"module"`), которая вызывает `create_vm()` и возвращает объект VM для последующих тестов:

```python
import pytest

@pytest.fixture(scope="session")
def vm():
    vm_instance = create_vm()
    yield vm_instance
    vm_instance.cleanup()  # например, удаляем VM в конце сессии
```

### 4. Используй фикстуру `vm` в других интеграционных тестах:

```python
def test_step_2(vm):
    # используй vm для следующего шага интеграции
    assert vm.do_something() == "ok"
```

---

## Важные моменты

* **Если `create_vm()` бросит исключение, тест `test_create_vm` упадёт, и фикстура `vm` не будет создана.** Тогда следующие тесты, зависящие от фикстуры `vm`, тоже упадут с ошибкой зависимой фикстуры — что корректно отражает, что инфраструктура не готова.
* Использование `scope="session"` или `module` гарантирует, что VM будет создана **один раз** на несколько тестов — экономия ресурсов.
* Таким образом ты **разделяешь ответственность**: отдельный тест — проверка получения VM, фикстура — предоставление VM в тесты.
* Если хочешь — можешь пометить тест получения VM как **маркером**, чтобы запускать его отдельно при необходимости.

---

## Альтернативы

* Можно использовать **`pytest` hook `pytest_runtest_setup`** или `autouse` фикстуры, чтобы **заранее создать VM перед всеми тестами**.
* Можно реализовать **кэширование результата** получения VM вне pytest (например, через внешний сервис или файл) и в фикстуре проверять готовность.

---

## Вывод

**Оптимальный способ — разделить:**

* бизнес-логику создания VM — в функцию
* отдельный тест для проверки этой функции
* фикстуру с широким scope для создания VM и передачи в другие тесты

Так сохраняется логика pytest, не дублируется работа и эффективно используется время и ресурсы.

---

Пример кода для  задачи — интеграционного теста с долгой и дорогой операцией по созданию VM, которую мы и тестируем, и потом используем как фикстуру для следующих тестов.

```python
import pytest

# Чистая функция создания VM — может бросать исключения
def create_vm():
    print("Создаем VM (долгий процесс)...")
    # здесь реальный код создания VM
    vm = {"id": 123, "status": "ready"}

    # проверка успешности (в реале может быть более сложной)
    if vm["status"] != "ready":
        raise RuntimeError("VM не готова")
    return vm

# Тестируем процесс создания VM отдельно
def test_create_vm():
    vm = create_vm()
    assert vm["status"] == "ready"

# Фикстура для передачи VM в другие тесты
@pytest.fixture(scope="session")
def vm():
    vm_instance = create_vm()
    yield vm_instance
    print("Удаляем VM после сессии")
    # vm_instance.cleanup()  # реальное удаление

# Другие интеграционные тесты используют фикстуру vm
def test_vm_operation_1(vm):
    print(f"Тестируем операцию с VM {vm['id']}")
    assert vm["status"] == "ready"

def test_vm_operation_2(vm):
    print(f"Еще один тест с VM {vm['id']}")
    assert vm["id"] == 123
```

---

### Как это работает?

* При запуске `pytest` сначала выполнится `test_create_vm()`. Если там `create_vm()` упадёт — сразу тест упадёт.
* Если `test_create_vm()` успешен, то фикстура `vm` создаст VM **один раз** на всю сессию и будет её передавать в тесты `test_vm_operation_1` и `test_vm_operation_2`.
* После всех тестов фикстура выполнит код очистки (например, удалит VM).
* Если ты запустишь только `test_vm_operation_1` или `test_vm_operation_2` без запуска `test_create_vm`, фикстура `vm` всё равно создаст VM и, если что-то пойдёт не так, тест упадёт.

---


